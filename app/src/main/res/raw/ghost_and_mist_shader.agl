

uniform float2 iResolution;
uniform float iTime;
uniform float isSpeaking;

float hash(float2 p) {
    return fract(sin(dot(p, float2(127.1, 311.7))) * 43758.5453123);
}

float noise(float2 p) {
    float2 i = floor(p);
    float2 f = fract(p);
    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
}

float fbm(float2 p) {
    float v = 0.0;
    float a = 0.5;
    float2 shift = float2(100.0);
    for (int i = 0; i < 5; ++i) {
        v += a * noise(p);
        p = p * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

half4 main(float2 fragCoord) {
    float2 uv = fragCoord / iResolution;
    float2 centered = (fragCoord - 0.5 * iResolution) / min(iResolution.x, iResolution.y);

    // === Floating animation ===
    float floatOffset = 0.03 * sin(iTime * 0.7);
    float2 ghostCenterUV = float2(0.5, 0.5 + floatOffset);

    // === Ghost body shape with tail wave ===
    float2 ghostUV = centered;
    ghostUV.y += floatOffset;
    float tailWave = 0.05 * sin(ghostUV.x * 12.0 + iTime * 2.0);
    float tailFactor = smoothstep(0.0, -0.3, ghostUV.y);
    ghostUV.y += tailWave * tailFactor;

    float radius = 0.4;
    float ghostBody = smoothstep(radius, radius - 0.1, length(ghostUV));
    float ghostMask = smoothstep(0.01, 0.99, ghostBody);

    // === Blinking logic ===
    float blinkSeed = floor(iTime / 6.0);
    float rand = fract(sin(blinkSeed * 91.345) * 47453.25);
    float nextBlinkTime = blinkSeed * 6.0 + rand * 3.0;
    float blinkDuration = 0.15;
    float timeSinceBlink = iTime - nextBlinkTime;
    float isBlinking = step(0.0, timeSinceBlink) * step(timeSinceBlink, blinkDuration);

    // === Eye shape and position ===
    float eyeRadiusX = 0.05;
    float eyeRadiusY = mix(0.05, 0.005, isBlinking);
    float2 leftEye = float2(-0.15, 0.05);
    float2 rightEye = float2( 0.15, 0.05);

    float2 leftDelta = ghostUV - leftEye;
    float2 rightDelta = ghostUV - rightEye;

    float leftEyeShape = step(length(float2(leftDelta.x / eyeRadiusX, leftDelta.y / eyeRadiusY)), 1.0);
    float rightEyeShape = step(length(float2(rightDelta.x / eyeRadiusX, rightDelta.y / eyeRadiusY)), 1.0);
    float eyes = leftEyeShape + rightEyeShape;

    // === Mouth shape ===
    float baseMouthY = 0.20;
    float mouthWidth = 0.15;
    float idleMouthHeight = 0.01;
    float talkingMouthHeight = 0.07 * abs(sin(iTime * 6.0));
    float mouthHeight = mix(idleMouthHeight, talkingMouthHeight, isSpeaking);

    float2 mouthDelta = ghostUV - float2(0.0, baseMouthY);
    float mouthShape = step(length(float2(mouthDelta.x / mouthWidth, mouthDelta.y / mouthHeight)), 1.0);

    // === Mist background using fbm noise ===
    float2 mistUV = uv * 3.0 + float2(iTime * 0.08, iTime * 0.03);
    float mistNoise = fbm(mistUV);

    float mistStrength = 0.5;
    float3 mistColor = float3(0.85) * (mistNoise * mistStrength);

    // === Ghost glow influence on mist ===
    float3 ghostGlowColor = float3(0.2 + 0.4 * isSpeaking, 1.0, 0.2 + 0.4 * isSpeaking);
    float ghostDist = length(ghostUV);
    float glowFalloff = smoothstep(0.5, 0.0, ghostDist);

    mistColor *= 1.0 - 0.3 * glowFalloff;
    mistColor += ghostGlowColor * glowFalloff * 1.5;

    // === Composite ghost + features over mist ===
    float3 finalColor = mix(mistColor, ghostGlowColor, ghostMask);
    if (eyes > 0.0) {
        finalColor = mix(finalColor, float3(0.0), eyes);
    }
    if (mouthShape > 0.0) {
        finalColor = mix(finalColor, float3(0.0), mouthShape);
    }

    return half4(finalColor, 1.0);
}
