uniform float2 iResolution;
uniform float iTime;
uniform float isSpeaking;

half4 main(float2 fragCoord) {
    float2 uv = fragCoord / iResolution;
    uv -= 0.5;
    uv.y *= 1.2;

    // === FLOATING MOTION ===
    float floatOffset = 0.03 * sin(iTime * 0.7);
    uv.y += floatOffset;

    // === Save floating UV for use in body and tail ===
    float2 bodyUV = uv;

    // === TAIL ANIMATION ===
    float tailWave = 0.05 * sin(bodyUV.x * 12.0 + iTime * 2.0);
    float tailFactor = smoothstep(0.0, -0.3, bodyUV.y);
    bodyUV.y += tailWave * tailFactor;

    // === BODY SHAPE ===
    float radius = 0.4;
    float dist = length(bodyUV);
    float body = smoothstep(radius, radius - 0.1, dist);

    // === BLINK TIMING ===
    float blinkSeed = floor(iTime / 6.0);
    float rand = fract(sin(blinkSeed * 91.345) * 47453.25);
    float nextBlinkTime = blinkSeed * 6.0 + rand * 3.0;
    float blinkDuration = 0.15;
    float timeSinceBlink = iTime - nextBlinkTime;
    float isBlinking = step(0.0, timeSinceBlink) * step(timeSinceBlink, blinkDuration);

    // === EYES ===
    float eyeRadiusX = 0.05;
    float eyeRadiusY = mix(0.05, 0.005, isBlinking);

    // Eye positions are static (relative to ghost center)
    float2 leftEye = float2(-0.15, 0.05);
    float2 rightEye = float2(0.15, 0.05);

    // Calculate deltas using floating uv (same as ghost movement)
    float2 leftDelta = uv - leftEye;
    float2 rightDelta = uv - rightEye;

    float leftEyeShape = step(length(float2(leftDelta.x / eyeRadiusX, leftDelta.y / eyeRadiusY)), 1.0);
    float rightEyeShape = step(length(float2(rightDelta.x / eyeRadiusX, rightDelta.y / eyeRadiusY)), 1.0);

    float eyes = leftEyeShape + rightEyeShape;

    // === COLOR ===
    float glow = 0.4 + 0.4 * isSpeaking;
    float3 color = mix(float3(0.0), float3(0.2 + glow, 1.0, 0.2 + glow), body);

    if (eyes > 0.0) {
        color = float3(0.0); // black eyes
    }

    float alpha = max(body, eyes);
    return half4(color, alpha);
}

